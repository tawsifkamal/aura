{
  "project": "Aura",
  "branchName": "main",
  "description": "TypeScript-only Claude Code skill and PR bot that auto-generate Screen Studio-style demo videos of frontend changes using the browser-use TypeScript library, run in Daytona sandboxes, integrate Laminar and Supermemory for browser intelligence/observability/context, store data and videos in Convex, upload to a dashboard, comment live status on GitHub, email results via AgentMail, and deliver videos to user-linked channels (Slack, Discord, etc.) via Composio with conversational editing support",
  "userStories": [
    {
      "id": "US-001",
      "title": "Create basic skill file structure",
      "description": "Set up the Claude Code skill that can be invoked with /record-demo",
      "acceptanceCriteria": [
        "Create skill file at ~/.claude/commands/record-demo.md",
        "Skill is discoverable via /record-demo command",
        "Skill contains placeholder prompt structure",
        "Implementation baseline is TypeScript-only (Node.js/TS), with no Python runtime dependency for core flow"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Check Claude Code docs for skill file format"
    },
    {
      "id": "US-002",
      "title": "Detect web app and changed files",
      "description": "Skill prompts Claude to analyze git diff and identify what changed",
      "acceptanceCriteria": [
        "Prompt instructs Claude to run git diff",
        "Detect if project is web app (package.json with react/vue/next/vite)",
        "Extract list of changed component/page files",
        "Identify likely affected routes from file paths",
        "Use code diffs as context to determine which frontend surfaces the browser agent should navigate to"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Focus on React/Next.js apps first"
    },
    {
      "id": "US-003",
      "title": "Start dev server and wait for ready",
      "description": "Skill prompts Claude to start the dev server before recording",
      "acceptanceCriteria": [
        "Detect start script from package.json (dev, start, etc.)",
        "Start server in background",
        "Wait for server to be ready (poll localhost)",
        "Handle common ports (3000, 5173, 8080)"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Use Bash tool for server, need to handle cleanup"
    },
    {
      "id": "US-004",
      "title": "Navigate and record with browser-use",
      "description": "Use the browser-use agent to browse the app and record video",
      "acceptanceCriteria": [
        "Prompt instructs Claude to use the browser-use TypeScript library/agent to open app routes",
        "Use browser-use TypeScript APIs for navigation and interactions (not Python browser-use bindings)",
        "Integrate browser-use runs with Laminar tracing/observability",
        "Integrate browser-use runs with Supermemory so prior runs and route intelligence can be recalled",
        "Visit routes affected by changes",
        "Take screenshots or record interactions",
        "Save output to demos/ folder with timestamp"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Relies on browser-use agent and browser tooling being configured"
    },
    {
      "id": "US-005",
      "title": "AI-driven interaction based on diff",
      "description": "Claude analyzes the diff and decides what to click/test",
      "acceptanceCriteria": [
        "Prompt tells Claude to read the actual code changes",
        "Identify interactive elements (buttons, forms, etc.) that changed",
        "Generate interaction plan",
        "Execute interactions via browser-use"
      ],
      "priority": 5,
      "passes": true,
      "notes": "This is the smart part - Claude reads diff and decides actions"
    },
    {
      "id": "US-006",
      "title": "Generate Screen Studio-style video and summary",
      "description": "Output a cinematic demo video and summary of what was tested with media",
      "acceptanceCriteria": [
        "Create demos/[timestamp]/ folder",
        "Produce Screen Studio-style video output with smooth zoom-in emphasis on click/type actions",
        "Render a synthetic smooth cursor animation between interaction targets instead of relying on raw browser cursor movement",
        "Cursor animation path and timing should be deterministic and visually smooth across steps",
        "Save screenshots of each step",
        "Generate summary.md with what was tested",
        "Print path to user when done"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Requires post-processing layer for zoom and cursor interpolation effects"
    },
    {
      "id": "US-007",
      "title": "Upload generated videos to dashboard",
      "description": "All generated demo videos should be uploaded to a dashboard page that can be shared",
      "acceptanceCriteria": [
        "Create a dashboard page that lists uploaded demo videos",
        "Dashboard UI uses a strict black-and-white visual theme (no colorful gradients/glows by default)",
        "Use sharp, edged corners across cards, panels, buttons, and inputs (avoid overly rounded styling)",
        "Visual design quality should avoid generic 'AI slop' aesthetics and follow deliberate spacing/typography hierarchy",
        "Dashboard is highly responsive across mobile, tablet, and desktop breakpoints",
        "Use Convex as the primary database for run metadata and dashboard indexing",
        "Use Convex storage for uploaded demo videos and related media artifacts",
        "Each upload stores metadata: timestamp, branch/PR, commit SHA, and summary",
        "Each generated run returns a stable dashboard URL for the uploaded video",
        "Dashboard supports both Claude skill runs and PR-triggered runs"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Dashboard is the canonical location for all demo artifacts, backed by Convex, with a clean black-and-white editorial UI style"
    },
    {
      "id": "US-008",
      "title": "Claude skill response includes dashboard link",
      "description": "When used through the Claude skill, Claude replies with the dashboard page URL for the generated video",
      "acceptanceCriteria": [
        "After a successful skill run, Claude response includes the dashboard link",
        "Response also includes short summary of what was recorded",
        "Link points to the specific uploaded run, not only the dashboard root"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Optimizes handoff from local skill execution to shareable artifact"
    },
    {
      "id": "US-009",
      "title": "PR bot uploads to dashboard and comments with live status",
      "description": "For pull requests, GitHub bot uploads videos to dashboard, embeds video in PR comment, and continuously updates that same comment with live status",
      "acceptanceCriteria": [
        "On PR open/update, bot triggers demo generation using code diff as navigation context",
        "Bot uploads resulting video to the dashboard and captures dashboard link",
        "Bot posts a PR comment containing embedded video preview plus dashboard link",
        "Bot uses a single persistent PR comment that is edited in place for status updates",
        "Status lifecycle includes queued, running, uploading, completed, and failed states",
        "Final comment includes summary of tested frontend areas inferred from diff"
      ],
      "priority": 9,
      "passes": true,
      "notes": "Avoid comment spam by continuously editing one canonical bot comment"
    },
    {
      "id": "US-010",
      "title": "Run recording pipeline in Daytona sandbox",
      "description": "Execute the demo generation workflow inside Daytona sandbox environments for isolation and reproducibility",
      "acceptanceCriteria": [
        "Recording pipeline runs in a Daytona sandbox for both Claude skill and PR bot flows",
        "Sandbox image includes browser-use TypeScript library dependencies and video rendering toolchain",
        "Sandbox runtime uses Node.js + TypeScript toolchain for all orchestration components",
        "Artifacts can be exported from the sandbox to Convex storage/dashboard pipeline",
        "Pipeline can be resumed or retried without losing run state metadata"
      ],
      "priority": 10,
      "passes": true,
      "notes": "Daytona is the default execution runtime for untrusted or variable project code"
    },
    {
      "id": "US-011",
      "title": "Integrate Laminar for run traces and debugging",
      "description": "Capture end-to-end traces for browser-use runs and expose them for debugging and reliability analysis",
      "acceptanceCriteria": [
        "Each demo generation run emits Laminar trace data",
        "Trace links are associated with run records in Convex metadata",
        "Failures include Laminar trace references in PR comment or Claude response",
        "Trace data captures tool steps, browser actions, and error points"
      ],
      "priority": 11,
      "passes": true,
      "notes": "Laminar provides observability for agent workflows"
    },
    {
      "id": "US-012",
      "title": "Integrate Supermemory for cross-run context",
      "description": "Use Supermemory to persist and retrieve relevant prior run context that improves route selection and interaction planning",
      "acceptanceCriteria": [
        "Store summarized run context and tested areas into Supermemory",
        "Retrieve relevant prior context using branch, route, or component similarity",
        "Use retrieved context to refine browser-use navigation/interaction plan",
        "Allow disabling Supermemory retrieval for deterministic baseline runs"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Supermemory enhances agent context engineering across sessions"
    },
    {
      "id": "US-013",
      "title": "Email final demo results via AgentMail",
      "description": "Send run completion emails with dashboard and media links through AgentMail as the default email delivery channel. AgentMail is one delivery channel among many; Composio handles routing to user-linked platforms (Slack, Discord, etc.)",
      "acceptanceCriteria": [
        "On completion (success or failure), send an email summary via AgentMail",
        "Email includes dashboard run URL, embedded or linked video, status, and short tested-areas summary",
        "For PR-triggered runs, include PR link and final bot comment link in email",
        "Email delivery failures are logged and surfaced in run status metadata",
        "AgentMail acts as the default email channel; delivery to other platforms is handled by Composio (see US-018)"
      ],
      "priority": 13,
      "passes": true,
      "notes": "AgentMail is the email-specific channel. For Slack, Discord, and other platforms, delivery is routed through Composio integration (US-018)"
    },
    {
      "id": "US-014",
      "title": "In-dashboard post-editing like Screen Studio",
      "description": "Allow users to edit generated videos after creation directly inside the dashboard with a feature-rich editor. All editing operations are backed by a shared backend API so the same capabilities are accessible from both the dashboard GUI and external integrations (Composio conversational edits)",
      "acceptanceCriteria": [
        "Users can crop regions of the video after generation and preview results before saving",
        "Users can trim/split timeline sections and reorder or remove segments",
        "Users can adjust cursor emphasis, zoom intensity, and motion smoothing in post-processing",
        "Users can apply and tweak style presets to achieve Screen Studio-like polish",
        "Editing operations are non-destructive, with ability to revert to the original render",
        "Edited versions are saved as new versioned artifacts linked to the original run",
        "All editing operations are exposed via a backend API consumable by both the dashboard UI and external integrations (Composio)",
        "Backend editing API supports crop, trim, split, zoom, cursor emphasis, and style preset operations"
      ],
      "priority": 14,
      "passes": true,
      "notes": "Editor should be powerful and production-grade, not a minimal crop-only tool. The backend API is the single source of truth for edits — the dashboard GUI and Composio conversational edits (US-019) both call it"
    },
    {
      "id": "US-015",
      "title": "Advanced export controls (MP4, GIF, FPS, quality)",
      "description": "Provide export options from the dashboard for multiple formats and rendering quality settings",
      "acceptanceCriteria": [
        "Users can export edited videos as MP4 and GIF",
        "Users can select FPS (for example: 24/30/60) and output resolution",
        "Users can control bitrate/quality and output file size constraints",
        "Exports support preset profiles (Web share, high quality, lightweight preview)",
        "Export jobs show progress, ETA, success/failure status, and downloadable outputs",
        "Export metadata and files are persisted in Convex-linked run records"
      ],
      "priority": 15,
      "passes": true,
      "notes": "Use sane defaults but expose advanced controls for power users"
    },
    {
      "id": "US-016",
      "title": "AWS-accelerated video processing pipeline",
      "description": "Use AWS infrastructure for scalable render/transcode/edit processing when available",
      "acceptanceCriteria": [
        "Video edit and export jobs can run on AWS-backed workers for scalability",
        "Pipeline supports queueing, retries, idempotency keys, and dead-letter handling",
        "System can optionally use hardware-accelerated transcoding where available",
        "Processing status events stream back to dashboard and PR/skill status surfaces",
        "If AWS processing is unavailable, system falls back to a local/Daytona-compatible path",
        "Cost and processing telemetry are captured per job for optimization and credit tracking"
      ],
      "priority": 16,
      "passes": true,
      "notes": "AWS credits should be leveraged for heavy video workloads and faster export turnaround"
    },
    {
      "id": "US-017",
      "title": "CI app and webhook server for PR-triggered runs",
      "description": "Build a GitHub App that receives PR webhook events and dispatches demo generation pipeline jobs. This is the trigger mechanism for all PR-automated flows",
      "acceptanceCriteria": [
        "Register and configure a GitHub App with PR event webhook permissions",
        "Webhook server receives PR open/update/synchronize events and validates signatures",
        "Server dispatches pipeline jobs to Daytona sandbox (or local fallback) with PR metadata (repo, branch, commit SHA, diff)",
        "Job state is tracked in Convex with status lifecycle: queued, running, uploading, completed, failed",
        "Server updates the persistent PR comment (US-009) with live status as the job progresses",
        "Supports retry/re-run via PR comment command or dashboard action",
        "Webhook server is deployable as a standalone service (e.g., Node.js on Fly.io, Railway, or AWS)"
      ],
      "priority": 17,
      "passes": true,
      "notes": "This is the backbone of the PR automation flow. US-009 depends on this for the actual trigger mechanism"
    },
    {
      "id": "US-018",
      "title": "Composio integration for multi-channel delivery",
      "description": "Integrate Composio to deliver completed demo videos to whatever channels the user has linked — Slack, Discord, email, or other platforms. Users configure their preferred delivery channels and Composio routes results accordingly",
      "acceptanceCriteria": [
        "Integrate Composio SDK for multi-channel delivery routing",
        "Users can link delivery channels (Slack, Discord, email, etc.) via Composio OAuth/connection flows",
        "Delivery preferences are stored per-user (or per-repo) in Convex",
        "On pipeline completion, video and summary are delivered to all user-linked channels via Composio",
        "Delivery includes dashboard link, video embed/attachment (where supported), and run summary",
        "Fallback to AgentMail email (US-013) if no Composio channels are linked",
        "Delivery failures per channel are logged and surfaced in run metadata without blocking other channels"
      ],
      "priority": 18,
      "passes": true,
      "notes": "Composio is the routing layer for non-email delivery. AgentMail (US-013) handles email specifically. Users should be able to receive videos wherever they work"
    },
    {
      "id": "US-019",
      "title": "Conversational video editing via Composio channels",
      "description": "Allow users to reply to delivered demo videos with natural language edit requests through their linked channel (Slack, Discord, etc.). Edit prompts are routed back to the editing API (US-014) and the updated video is re-delivered",
      "acceptanceCriteria": [
        "Users can reply to a delivered video in their channel (Slack thread, Discord reply, email reply) with edit instructions",
        "Composio routes the reply back to the Aura server with the original run context",
        "Server parses natural language edit requests (e.g., 'zoom in on the button click', 'trim the first 5 seconds', 'make it a GIF')",
        "Edit requests are translated into calls to the backend editing API (US-014)",
        "Updated video is re-rendered and re-delivered through the same channel",
        "Edit history is tracked as versioned artifacts in Convex, linked to the original run",
        "Users can request multiple rounds of edits in a conversational thread"
      ],
      "priority": 19,
      "passes": true,
      "notes": "This is the conversational counterpart to the dashboard GUI editor (US-014). Both use the same backend editing API. The NLP parsing layer translates free-text prompts into structured edit operations"
    },
    {
      "id": "US-020",
      "title": "Auto-generate test scripts for each pipeline stage",
      "description": "Automatically write comprehensive test scripts that validate every stage of the Aura pipeline — from diff detection through video generation, upload, delivery, and editing. Tests should be self-contained and runnable without manual setup",
      "acceptanceCriteria": [
        "Auto-generate unit tests for diff detection and route inference logic (US-002)",
        "Auto-generate integration tests for dev server startup and readiness polling (US-003)",
        "Auto-generate tests for browser-use navigation and interaction recording (US-004, US-005)",
        "Auto-generate tests for video post-processing pipeline (cursor animation, zoom, Screen Studio effects) (US-006)",
        "Auto-generate tests for Convex upload, metadata storage, and dashboard data retrieval (US-007)",
        "Auto-generate tests for PR bot comment lifecycle (create, update, status transitions) (US-009)",
        "Auto-generate tests for editing API operations (crop, trim, split, zoom, presets) (US-014)",
        "Auto-generate tests for export pipeline (MP4, GIF, FPS, resolution, quality) (US-015)",
        "Auto-generate tests for Composio delivery routing and channel fallback (US-018)",
        "Auto-generate tests for conversational edit parsing and round-trip re-delivery (US-019)",
        "All test files follow existing project conventions (Vitest or Jest, TypeScript, co-located or in __tests__/)",
        "Tests use mocks/stubs for external services (Convex, Composio, AgentMail, GitHub API, browser-use) so they can run offline",
        "Test scripts include descriptive names and comments explaining what each test validates"
      ],
      "priority": 20,
      "passes": true,
      "notes": "The agent should analyze each implemented module and write tests autonomously — not just scaffold empty test files. Tests should actually assert correctness"
    },
    {
      "id": "US-021",
      "title": "End-to-end validation and build verification",
      "description": "Run the full test suite, typecheck, lint, and build to verify the entire project compiles and passes all quality gates. Fix any issues found during validation",
      "acceptanceCriteria": [
        "Run TypeScript typecheck (tsc --noEmit) and fix all type errors",
        "Run linter (ESLint) and fix all lint violations",
        "Run the full test suite generated in US-020 and ensure all tests pass",
        "Run the project build (next build, tsc, or whatever the project uses) and ensure it succeeds with zero errors",
        "If any check fails, fix the underlying code and re-run until all checks are green",
        "Final validation output is logged with pass/fail summary for each gate (typecheck, lint, tests, build)",
        "Validation script can be run as a single command (e.g., npm run validate or a composite script)"
      ],
      "priority": 21,
      "passes": true,
      "notes": "This is the quality gate — nothing ships unless typecheck + lint + tests + build all pass. The agent should iterate on fixes, not just report failures"
    },
    {
      "id": "US-022",
      "title": "Create gap-tracking issue for missing coverage and incomplete areas",
      "description": "After tests and validation pass, audit the codebase for gaps — untested paths, missing error handling, unimplemented stubs, TODO/FIXME markers, and missing integration points. Create a GitHub issue cataloging all gaps with actionable items",
      "acceptanceCriteria": [
        "Scan codebase for TODO, FIXME, HACK, and XXX markers and catalog them",
        "Identify any user stories with thin or missing test coverage",
        "Identify missing error handling paths (e.g., network failures, invalid inputs, timeout scenarios)",
        "Identify any placeholder/stub implementations that need real logic",
        "Identify missing integration points between modules (e.g., Laminar traces not wired, Supermemory not connected)",
        "Create a single GitHub issue titled 'Aura: Coverage gaps and incomplete areas' with all findings organized by category",
        "Issue body includes checklist items so each gap can be tracked and closed individually",
        "Issue is labeled with 'enhancement' and 'tech-debt' labels (create labels if they don't exist)"
      ],
      "priority": 22,
      "passes": false,
      "notes": "This is a self-audit step — the agent finds its own blind spots and creates a trackable issue so nothing falls through the cracks"
    }
  ]
}
