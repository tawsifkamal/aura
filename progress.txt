## Codebase Patterns
- Claude Code custom skills go in `.claude/commands/<skill-name>.md` at project root
- Monorepo uses Turborepo with `apps/` and `packages/` workspaces
- Existing Python demo-recorder in `packages/demo-recorder/` — PRD requires TypeScript-only for core flow
- Project uses npm (not yarn/pnpm), see `package-lock.json`
- Quality checks: `turbo run build`, `turbo run lint`, `turbo run check-types`
- New Node.js packages: extend `@repo/typescript-config/base.json`, add `eslint.config.js` with `@repo/eslint-config/base`, set `type: "module"`
- Core utilities live in `packages/core/src/` — import with `@repo/core` or `@repo/core/<module>`
- ESLint `--max-warnings 0` means NO unused vars allowed (even with `_` prefix) — remove unused params entirely
- Convex backend lives in `apps/web/convex/` — schema in `schema.ts`, functions in `runs.ts`
- Convex `_generated/` uses `GenericDataModel` — cast query results to app types on the client side
- Exclude `convex/_generated/**` in ESLint config to avoid lint errors on auto-generated files
- Dashboard UI at `apps/web/` — strict B&W theme, sharp edges, CSS Modules, responsive grid
- Upload utility in `packages/core/src/convex-uploader.ts` — uses Convex HTTP API for uploads from CLI/pipeline
- PR bot in `packages/core/src/pr-bot.ts` — single persistent comment with `<!-- aura-bot -->` marker, status lifecycle
- Daytona sandbox orchestration in `packages/core/src/sandbox.ts` — create/exec/export/destroy lifecycle

---

## 2026-02-28 - US-001
- Created `/record-demo` Claude Code skill at `.claude/commands/record-demo.md`
- Skill is discoverable via `/record-demo` command (confirmed in skill listing)
- Contains full placeholder prompt structure: diff analysis, web app detection, dev server startup, browser-use recording, Screen Studio-style post-processing, and output reporting
- TypeScript-only baseline — no Python runtime dependency in the skill prompt
- Files changed: `.claude/commands/record-demo.md` (new)
- **Learnings for future iterations:**
  - Claude Code discovers skills from `.claude/commands/` directory automatically
  - The skill appears in the available skills list immediately after file creation
  - Existing `packages/plugin/skills/record-demo/SKILL.md` is the old Python-based version; the new `.claude/commands/record-demo.md` supersedes it
  - PRD says `~/.claude/commands/` (home dir) but project-level `.claude/commands/` is correct for project-scoped skills
---

## 2026-02-28 - US-002
- Created `@repo/core` package at `packages/core/` with TypeScript utilities
- `diff-analyzer.ts`: parses `git diff --name-status`, classifies files as component/page/route, deduplicates
- `web-app-detector.ts`: reads `package.json`, detects framework (Next.js, React, Vue, Vite, Angular, Svelte, Nuxt, Remix, Astro), finds dev script and port
- `route-inferrer.ts`: infers affected routes from changed file paths with confidence levels (high/medium/low), supports Next.js App Router, Pages Router, and generic patterns
- `index.ts`: re-exports all public APIs and types
- Updated `.claude/commands/record-demo.md` skill with detailed Step 1 instructions for diff analysis, web app detection, and route inference
- Files changed: `packages/core/` (new package), `.claude/commands/record-demo.md` (updated), `package-lock.json`
- **Learnings for future iterations:**
  - New packages need `eslint.config.js` importing from `@repo/eslint-config/base` for lint to work
  - Use `@repo/typescript-config/base.json` (not react-library) for Node.js-only packages
  - Package `type: "module"` and `.js` extensions in imports are required for NodeNext module resolution
  - The `parseDiffNameStatus` function is exported separately so it can be unit-tested without git
  - Route inference confidence levels help the browser agent prioritize which routes to visit
---

## 2026-02-28 - US-003
- Created `dev-server.ts` in `packages/core/src/` with dev server lifecycle management
- `startDevServer()`: spawns dev process in background, polls for HTTP readiness, returns handle with kill()
- `httpCheck()`: single HTTP GET probe to localhost port
- `waitForPort()`: polls with configurable timeout (default 60s) and interval (default 500ms)
- `findActivePort()`: scans common ports (3000, 5173, 8080, 4200, 4321, 8000) as fallback
- `resolveDevCommand()`: derives `npm run <script>` from WebAppInfo
- Handles already-running servers (returns no-op handle)
- Uses `detached: true` + process group kill for clean cleanup
- Updated skill prompt Step 2 with detailed server startup instructions
- Files changed: `packages/core/src/dev-server.ts` (new), `packages/core/src/index.ts` (updated), `.claude/commands/record-demo.md` (updated)
- **Learnings for future iterations:**
  - Use `process.kill(-pid, 'SIGTERM')` for process group cleanup (negative PID kills the group)
  - Set `FORCE_COLOR=0` env var to avoid ANSI escapes in captured output
  - Always check if port is already in use before spawning — avoids double-server issues
  - `detached: true` with `stdio: ["ignore", "pipe", "pipe"]` prevents zombie processes
---

## 2026-02-28 - US-004
- Created `browser-recorder.ts` in `packages/core/src/` with recording session orchestration
- `createSession()`: initializes recording session with ID, routes, output dir
- `createOutputDir()`: creates `demos/[timestamp]/screenshots/` structure
- `addStep()`: logs actions (navigate, click, type, screenshot) with timestamps
- `buildNavigationScript()`: converts InferredRoute[] to full URL list
- `writeSummary()`: generates `summary.md` with routes, steps, and diff context
- `buildLaminarMetadata()`: prepares Laminar tracing config for browser-use runs
- `buildSupermemoryQuery()`: prepares Supermemory context retrieval query
- Updated skill prompt Step 3 with detailed browser-use + Playwright instructions
- Files changed: `packages/core/src/browser-recorder.ts` (new), `packages/core/src/index.ts` (updated), `.claude/commands/record-demo.md` (updated)
- **Learnings for future iterations:**
  - browser-use npm package is built on Playwright — use Playwright directly for screenshots/video recording
  - Playwright `recordVideo: { dir, size }` in context options auto-saves video on context close
  - browser-use Agent takes `{ task, llm }` — configure with routes and diff context as the task description
  - Laminar and Supermemory are optional integrations — gate on env vars (LAMINAR_ENDPOINT, SUPERMEMORY_ENDPOINT)
  - Session ID format YYYYMMDD-HHMMSS doubles as the demos/ subfolder name
---

## 2026-02-28 - US-005
- Created `interaction-planner.ts` in `packages/core/src/` for AI-driven interaction planning
- `extractInteractiveElements()`: parses diff hunks for added HTML/JSX elements (button, input, form, etc.), ARIA roles, and event handlers (onClick, onSubmit, onChange)
- Smart selector extraction with priority: id > data-testid > aria-label > className > text content > tag fallback
- `generateInteractionPlan()`: maps elements to routes, deduplicates, sorts by confidence then action type, returns structured step list
- Graceful handling: missing elements are skipped without failing the recording
- Updated skill prompt Step 4 with detailed interaction plan generation and execution instructions
- Files changed: `packages/core/src/interaction-planner.ts` (new), `packages/core/src/index.ts` (updated), `.claude/commands/record-demo.md` (updated)
- **Learnings for future iterations:**
  - Use global regex patterns with `lastIndex = 0` reset before each test to avoid missed matches
  - Selector extraction from JSX is best-effort — data-testid is the most reliable
  - Event handler detection (onClick etc.) serves as a fallback when no HTML element is directly visible in the diff
  - Diff hunks keyed by file path allow mapping elements back to their source route
  - Wait times vary by action: 500ms for clicks, 2000ms for form submissions
---

## 2026-02-28 - US-006
- Created `video-processor.ts` in `packages/core/src/` for Screen Studio-style post-processing
- `interpolateCursorPath()`: cubic bezier interpolation between cursor keyframes, deterministic output
- `generateZoomKeyframes()`: creates zoom-in effects on click/type actions
- `getZoomAtTime()`: frame-level zoom with asymmetric easing (30% zoom-in, 70% zoom-out)
- Three style presets: default (balanced), minimal (subtle), dramatic (deep zoom + dark bg)
- `buildFFmpegCompositeCommand()`: generates FFmpeg command for H.264 MP4 with cursor overlay + zoom
- `prepareVideoProcessing()`: full pipeline — builds cursor path, zoom keyframes, manifest, FFmpeg command
- `writeRenderManifest()`: writes render-manifest.json with all processing metadata
- Updated skill prompt Step 5 with detailed post-processing instructions
- Files changed: `packages/core/src/video-processor.ts` (new), `packages/core/src/index.ts` (updated), `.claude/commands/record-demo.md` (updated)
- **Learnings for future iterations:**
  - ESLint in this project treats `_` prefixed unused params as warnings too — remove unused params entirely instead
  - Cubic bezier with control points along x-axis only produces natural horizontal cursor arcs
  - Asymmetric zoom (fast in, slow out) feels more natural than symmetric — use 30/70 split
  - FFmpeg `-movflags +faststart` is essential for web playback (moves moov atom to start)
  - `zoompan` filter in FFmpeg can do per-frame zoom but syntax is complex for dynamic keyframes
  - Render manifest JSON captures all processing metadata for debugging and reproducibility
---

## 2026-02-28 - US-007
- Created Convex backend for dashboard: schema with `runs` table (indexes: by_timestamp, by_status, by_branch)
- Convex functions: `list`, `get`, `create`, `updateStatus`, `attachVideo`, `attachScreenshots`, `generateUploadUrl`
- Dashboard homepage (`apps/web/app/page.tsx`): grid of run cards with status badges, video thumbnails, route chips
- Run detail page (`apps/web/app/runs/[runId]/page.tsx`): video player, metadata grid, summary, screenshots, error display
- Strict black-and-white visual theme with sharp edges (border-radius: 0), no color gradients
- Responsive layout: 3-col desktop, 2-col tablet, 1-col mobile via CSS Grid `auto-fill`
- ConvexClientProvider wraps the app in layout.tsx
- Created `convex-uploader.ts` in `packages/core/src/` for pipeline uploads via Convex HTTP API
- Updated skill prompt with Step 5f (upload to dashboard) and dashboard link in output
- Excluded `convex/_generated/**` from ESLint to avoid warnings on auto-generated files
- Files changed: `apps/web/convex/` (new), `apps/web/app/` (rewritten), `apps/web/eslint.config.js`, `apps/web/package.json`, `packages/core/src/convex-uploader.ts` (new), `packages/core/src/index.ts`, `.claude/commands/record-demo.md`, `package-lock.json`
- **Learnings for future iterations:**
  - Convex `_generated/server.d.ts` uses `GenericDataModel` — query return types lose schema info, so cast to app-defined types on the client
  - Use `RegisteredMutation` type annotation for mutations with inferred return types that reference internal Convex types (avoids TS2742)
  - Convex storage upload flow: generate upload URL via mutation → POST file to URL → get storageId → attach to document
  - Next.js 16 uses `params: Promise<...>` for dynamic routes — unwrap with `use(props.params)`
  - CSS Modules `composes` works for badge variants but the composed class must be defined in the same file
  - Convex local dev runs on port 3210 (HTTP API) and 3211 (site URL)
  - Root `convex/` directory is created by `npx convex dev` when run from monorepo root — don't commit it
---

## 2026-02-28 - US-008
- Updated skill prompt Step 5g to explicitly require dashboard link in Claude's response
- Response format now mandates: dashboard URL (specific run, not root), short summary, routes tested, local file paths
- `createRun()` from `@repo/core/convex-uploader` already returns `{ runId, dashboardUrl }` with `/runs/<runId>` path
- Added graceful fallback: if upload fails, still report local files with error note
- Files changed: `.claude/commands/record-demo.md`
- **Learnings for future iterations:**
  - The skill prompt is the single source of truth for Claude's response format — be explicit about what must appear
  - `dashboardUrl` from `createRun()` already contains the full specific-run URL — no need to construct it separately
---

## 2026-02-28 - US-009
- Created `pr-bot.ts` in `packages/core/src/` for GitHub PR comment lifecycle management
- `findExistingComment()`: searches PR comments for the `<!-- aura-bot -->` marker to find the canonical bot comment
- `postOrUpdateComment()`: creates or edits the single persistent comment (avoids comment spam)
- `updateCommentStatus()`: transitions comment through status lifecycle (queued → running → uploading → completed/failed)
- `buildCommentBody()`: renders markdown comment body with status, video preview, dashboard link, summary, and routes tested
- Comment body uses a hidden HTML marker (`<!-- aura-bot -->`) for identification
- Status-specific rendering: queued/running show spinner text, completed shows video + dashboard link + summary, failed shows error
- Files changed: `packages/core/src/pr-bot.ts` (new), `packages/core/src/index.ts` (updated)
- **Learnings for future iterations:**
  - GitHub API uses `issues/comments` endpoint for PR comments (PRs are issues)
  - Hidden HTML comments (`<!-- marker -->`) are the standard pattern for bot comment identification
  - Always use `per_page=100` when searching for existing comments to avoid pagination issues on busy PRs
  - The `X-GitHub-Api-Version` header is recommended for API stability
---

## 2026-02-28 - US-010
- Created `sandbox.ts` in `packages/core/src/` for Daytona sandbox orchestration
- `createSandbox()`: spawns Daytona workspace with repo, branch, image, and env vars
- `runInSandbox()`: executes commands inside sandbox with output capture and artifact parsing
- `exportArtifact()`: copies files from sandbox to local path via `daytona cp`
- `destroySandbox()`: best-effort cleanup via `daytona delete --force`
- `runPipeline()`: sequential multi-step execution with early exit on failure
- `buildRecordingPipelineSteps()`: standard recording pipeline (install, browsers, build, record)
- Pipeline is resumable — run state metadata lives in Convex, sandbox is stateless
- Falls back gracefully when `daytona` CLI is not available (sandbox status = "failed")
- Files changed: `packages/core/src/sandbox.ts` (new), `packages/core/src/index.ts` (updated)
- **Learnings for future iterations:**
  - Daytona CLI uses `daytona create/exec/cp/delete` subcommands
  - Use `maxBuffer: 50MB` for exec to handle large build outputs
  - Parse artifact paths from stdout using regex pattern matching on "artifact:", "output:", etc.
  - Best-effort cleanup pattern: wrap destroy in try/catch, never throw on cleanup failure
---
